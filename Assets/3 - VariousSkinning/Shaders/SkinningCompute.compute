CGPROGRAM

#include <DataDefination.cginc>

#pragma kernel LinearBlendCompute
#pragma kernel DualQuaternionBlendCompute
#pragma kernel OptimizedCenterOfRotationCompute

#pragma kernel DataToDataCompute

// Start of Linear Blend Skinning
/*
*  Mesh source and bone weights and index
*/
StructuredBuffer<VertexInfo> meshBuffer;
//StructuredBuffer<BoneInfoPerVertex> boneInfoBuffer;

/*
*  Converted mesh data;
*/
RWStructuredBuffer<RenderData> meshStream;

/*
 *  LinearBlendSkinning Data
 */
StructuredBuffer<float4x4> currentPoseMatrixBuffer;
StructuredBuffer<float4x4> restPoseMatrixBuffer;

cbuffer Config
{
    uint vertexCount;
}

inline float4x4 GetCurrentPoseMatrix(int boneIndex)
{
    return currentPoseMatrixBuffer[boneIndex];
}

inline float4x4 GetRestPoseMatrix(int boneIndex)
{
    return restPoseMatrixBuffer[boneIndex];
}

#define MAX_THREAD_ID 1024	

[numthreads(MAX_THREAD_ID, 1, 1)]
void LinearBlendCompute(uint3 threadID : SV_DispatchThreadID)
{
    for (uint realVertexID = threadID[0]; realVertexID < vertexCount; realVertexID += MAX_THREAD_ID)
    {
        VertexInfo info = meshBuffer[realVertexID];

        float4x4 
            transformMatrix = mul(GetCurrentPoseMatrix(info.index[0]), GetRestPoseMatrix(info.index[0]));
        float4 
            position =  mul(
                            transformMatrix, 
                            float4(meshBuffer[realVertexID].position.xyz, 1)
                        ) * info.weight[0];
        float4
            normal =    mul(
                            transformMatrix, 
                            float4(meshBuffer[realVertexID].normal.xyz, 0)
                        ) * info.weight[0];

        if (info.weight[1] > 0)
        {
            transformMatrix = mul(GetCurrentPoseMatrix(info.index[1]), GetRestPoseMatrix(info.index[1]));
            position += mul(
                            transformMatrix, 
                            float4(meshBuffer[realVertexID].position.xyz, 1)
                        ) * info.weight[1];
            
            normal +=   mul(
                            transformMatrix,
                            float4(meshBuffer[realVertexID].normal.xyz, 0)
                        ) * info.weight[1];
        }
            
        if (info.weight[2] > 0)
        {
            transformMatrix = mul(GetCurrentPoseMatrix(info.index[2]), GetRestPoseMatrix(info.index[2]));
            position += mul(
                            transformMatrix, 
                            float4(meshBuffer[realVertexID].position.xyz, 1)
                        ) * info.weight[2];
            
            normal += mul(
                            transformMatrix,
                            float4(meshBuffer[realVertexID].normal.xyz, 0)
                        ) * info.weight[2];

        }
        
        if(info.weight[3] > 0)
        {
            transformMatrix = mul(GetCurrentPoseMatrix(info.index[3]), GetRestPoseMatrix(info.index[3]));
            position += mul(
                            transformMatrix,
                            float4(meshBuffer[realVertexID].position.xyz, 1)
                        ) * info.weight[3];
            
            normal += mul(
                            transformMatrix,
                            float4(meshBuffer[realVertexID].normal.xyz, 0)
                        ) * info.weight[3];
        }
        
        meshStream[realVertexID].position = position;
        meshStream[realVertexID].normal = normalize(normal);
        meshStream[realVertexID].uv = meshBuffer[realVertexID].uv;
    }
}

// Start of Dual Quaternion Blend Skinning
#include <DualQuaternion.cginc>

StructuredBuffer<DQ> currentPoseDQBuffer;
StructuredBuffer<DQ> restPoseDQBuffer;

inline DQ GetCurrentPoseDQ(int boneIndex)
{
    return currentPoseDQBuffer[boneIndex];
}

inline DQ GetRestPoseDQ(int boneIndex)
{
    return restPoseDQBuffer[boneIndex];
}

[numthreads(MAX_THREAD_ID, 1, 1)]
void DualQuaternionBlendCompute(uint3 threadID : SV_DispatchThreadID)
{
    for (uint realVertexID = threadID[0]; realVertexID < vertexCount; realVertexID += MAX_THREAD_ID)
    {
        VertexInfo info = meshBuffer[realVertexID];

        DQ	compareDQ = mulDQ(GetCurrentPoseDQ(info.index[0]), GetRestPoseDQ(info.index[0])),
			curPoseDQ = multiply(compareDQ, info.weight[0]),
            poseDQBuffer, otherRestPoseDQ;

		if (info.weight[1] > 0)
		{
			poseDQBuffer = mulDQ(GetCurrentPoseDQ(info.index[1]), GetRestPoseDQ(info.index[1]));

			if (dot(compareDQ.real, poseDQBuffer.real) >= 0)
				curPoseDQ = add(curPoseDQ, multiply(poseDQBuffer, info.weight[1]));
			else
				curPoseDQ = minus(curPoseDQ, multiply(poseDQBuffer, info.weight[1]));
		}

		if (info.weight[2] > 0)
		{
			poseDQBuffer = mulDQ(GetCurrentPoseDQ(info.index[2]), GetRestPoseDQ(info.index[2]));

			if (dot(compareDQ.real, poseDQBuffer.real) >= 0)
				curPoseDQ = add(curPoseDQ, multiply(poseDQBuffer, info.weight[2]));
			else
				curPoseDQ = minus(curPoseDQ, multiply(poseDQBuffer, info.weight[2]));
		}

		if (info.weight[3] > 0)
		{
			poseDQBuffer = mulDQ(GetCurrentPoseDQ(info.index[3]), GetRestPoseDQ(info.index[3]));

			if (dot(compareDQ.real, poseDQBuffer.real) >= 0)
				curPoseDQ = add(curPoseDQ, multiply(poseDQBuffer, info.weight[3]));
			else
				curPoseDQ = minus(curPoseDQ, multiply(poseDQBuffer, info.weight[3]));
		}
		 
        DQ dqTransfrom = normalizeDQ(curPoseDQ);

        meshStream[realVertexID].position = float4(transformPositionByDQ(dqTransfrom, meshBuffer[realVertexID].position.xyz), 1);
        meshStream[realVertexID].normal = float4(normalize(transformPositionByQ(dqTransfrom.real, meshBuffer[realVertexID].normal.xyz)), 0);
        meshStream[realVertexID].uv = meshBuffer[realVertexID].uv;
    }
}
 
Buffer<float4> restPoseRotationBuffer;
Buffer<float4> currentPoseRotationBuffer;

Buffer<float3> centerOfRotationBuffer;

inline float4 GetCurrentPoseRotation(int boneIndex)
{
    return currentPoseRotationBuffer[boneIndex];
}

inline float4 GetRestPoseRotation(int boneIndex)
{
    return restPoseRotationBuffer[boneIndex];
}

[numthreads(MAX_THREAD_ID, 1, 1)]
void OptimizedCenterOfRotationCompute(uint3 threadID : SV_DispatchThreadID)
{
    for (uint realVertexID = threadID[0]; realVertexID < vertexCount; realVertexID += MAX_THREAD_ID)
    {
		VertexInfo info = meshBuffer[realVertexID];

		float4x4
			transformMatrix = mul(GetCurrentPoseMatrix(info.index[0]), GetRestPoseMatrix(info.index[0]));
		float3 centerOfRotation = centerOfRotationBuffer[realVertexID];
		float4
			LBSCenterOfRotation = mul(
				transformMatrix,
				float4(centerOfRotation, 1)
			) * info.weight[0];
		float4 
			compareRotation = mulQxQ(GetCurrentPoseRotation(info.index[0]), GetRestPoseRotation(info.index[0])),
			currentPoseRotation = compareRotation * info.weight[0];
		float4 rotationBuffer;

		if (info.weight[1] > 0)
		{
			transformMatrix = mul(GetCurrentPoseMatrix(info.index[1]), GetRestPoseMatrix(info.index[1]));
			LBSCenterOfRotation += mul(
				transformMatrix,
				float4(centerOfRotation, 1)
			) * info.weight[1];

			rotationBuffer = mulQxQ(GetCurrentPoseRotation(info.index[1]), GetRestPoseRotation(info.index[1]));

			if (dot(compareRotation, rotationBuffer) >= 0)
				currentPoseRotation += rotationBuffer * info.weight[1];
			else
				currentPoseRotation -= rotationBuffer * info.weight[1];
		}

		if (info.weight[2] > 0)
		{
			transformMatrix = mul(GetCurrentPoseMatrix(info.index[2]), GetRestPoseMatrix(info.index[2]));
			LBSCenterOfRotation += mul(
				transformMatrix,
				float4(centerOfRotation, 1)
			) * info.weight[2];

			rotationBuffer = mulQxQ(GetCurrentPoseRotation(info.index[2]), GetRestPoseRotation(info.index[2]));

			if (dot(compareRotation, rotationBuffer) >= 0)
				currentPoseRotation += rotationBuffer * info.weight[2];
			else
				currentPoseRotation -= rotationBuffer * info.weight[2];
		}

		if (info.weight[3] > 0)
		{
			transformMatrix = mul(GetCurrentPoseMatrix(info.index[3]), GetRestPoseMatrix(info.index[3]));
			LBSCenterOfRotation += mul(
				transformMatrix,
				float4(centerOfRotation, 1)
			) * info.weight[3];

			rotationBuffer = mulQxQ(GetCurrentPoseRotation(info.index[3]), GetRestPoseRotation(info.index[3]));

			if (dot(compareRotation, rotationBuffer) >= 0)
				currentPoseRotation += rotationBuffer * info.weight[3];
			else
				currentPoseRotation -= rotationBuffer * info.weight[3];
		}

		float4 rotation = normalize(currentPoseRotation);

		meshStream[realVertexID].position = 
			float4(
				LBSCenterOfRotation.xyz 
				- transformPositionByQ(rotation, centerOfRotation) 
				+ transformPositionByQ(rotation, info.position.xyz), 
				1);
		meshStream[realVertexID].normal = float4(transformPositionByQ(rotation, info.normal), 0);
		meshStream[realVertexID].uv = meshBuffer[realVertexID].uv;
	}
}

// This computation kernel just copy source data
[numthreads(MAX_THREAD_ID, 1, 1)]
void DataToDataCompute(uint3 threadID : SV_DispatchThreadID)
{
    for (uint realVertexID = threadID[0]; realVertexID < vertexCount; realVertexID += MAX_THREAD_ID)
    {
        meshStream[realVertexID].position = meshBuffer[realVertexID].position;
        meshStream[realVertexID].normal = meshBuffer[realVertexID].normal;
        meshStream[realVertexID].uv = meshBuffer[realVertexID].uv;
    }
}

ENDCG
